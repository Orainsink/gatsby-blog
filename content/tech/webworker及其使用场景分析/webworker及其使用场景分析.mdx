---
title: web workers学习及其应用场景探索
date: 2020-11-26 09:33:25
description: web worker是独立于js主线程之外的独立线程, 可以在不堵塞主线程的情况下执行一些有限制的js脚本, 运用得当的话可以极大地提升页面性能
tags: [性能,js]
categories: tech
---

## Web Workers介绍

web workers是独立于js主线程之外的线程, 可以在不堵塞主线程的情况下执行一些有限制的js脚本, web workers无法操纵DOM但是可以调用一些浏览器提供的DOM方法，workers在统计或计算数据方面运用得当的话可以极大地提升页面性能。

workers和主线程间的数据传递通过这样的消息机制进行——双方都使用`postMessage()`方法发送各自的消息，使用`onmessage`事件处理函数来响应消息（消息被包含在`Message`事件的data属性中）。这个过程中数据并不是被共享而是被复制。

关于其更多特性和限制，话不多说，直接上[MDN文档](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers) 

使用web workers之前，有必要认真读一次文档，因为web workers在不同浏览器支持的API不一样。

> 以下的应用场景, 默认你已经读过MDN文档, 对 web workers 有初步的了解

## OffscreenCanvas(离屏canvas)

[MDN文档](https://developer.mozilla.org/zh-CN/docs/Web/API/OffscreenCanvas)

`OffscreenCanvas`提供了一个可以脱离屏幕渲染的canvas对象。它在窗口环境和web worker环境均有效。他与DOM中的canvas对象用法基本相同。

即我们可以在web worker里面对`offscreenCanvas`进行计算和渲染，计算过程和渲染主线程分开，这样就不会阻塞主线程。

一般计算量较小的canvas当然用不到，但是`offscreenCanvas`可以和`three.js`配合进行一些教复杂的动画渲染：

效果就像这样：[threejs example](https://threejs.org/examples/webgl_worker_offscreencanvas.html)

[完整代码](https://github.com/mrdoob/three.js/blob/master/examples/webgl_worker_offscreencanvas.html)

```html
<canvas id="canvas"></canvas>
```

```js
const canvas = document.getElementById( 'canvas' );
if ( 'transferControlToOffscreen' in canvas ) {

				const offscreen = canvas.transferControlToOffscreen();
				const worker = new Worker( 'jsm/offscreen/offscreen.js', { type: 'module' } );
				worker.postMessage( {
					drawingSurface: offscreen,
					width: canvas.clientWidth,
					height: canvas.clientHeight,
					pixelRatio: window.devicePixelRatio,
					path: '../../'
				}, [ offscreen ] );

			}
```

因为使用`offscreenCanvas`过后一些DOM API就不能使用了，而且在react-three-fiber中使用会有一点麻烦，所以我放弃了在博客中使用。

