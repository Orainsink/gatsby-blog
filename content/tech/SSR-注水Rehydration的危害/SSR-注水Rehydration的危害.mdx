---
title: SSR-注水(Rehydration)的危险
date: 2020-11-23 22:43:27
description: 深入了解gatsby和react
tags: [ssr, react, gatsby]
categories: tech
---

> 前段时间我发现自己的博客网站 html 结构发生了错位, 一些组件，比如 footer 跑到了奇奇怪怪的地方，这个 bug 一度让我手足无措，因为检查 react 代码我并没有发现任何错误。找了很久的资料， 才发现是 SSR 的问题。这
>
> 翻译一篇解释得比较好点的文章，原文： https://www.joshwcomeau.com/react/the-perils-of-rehydration/

# The Perils of Rehydration(注水的危险)

> An Eye-Opening Realization about Gatsby and React

​ 我最近遇到了一个很奇怪的问题。在开发过程中，一切都是那么顺畅，但在生产打包过后中，我博客的底部却发生了一些……意想不到的事情：![ssr1](ssr1.png)

<center>乱成一锅粥的UI</center>

<center>
  (译者: 哈哈哈, 如你所见, html 错位了, 我的博客错位得更彻底, 完全面目全非)
</center>

​ 我在 devtools 中的 Elements 选项卡进行了一点挖掘，发现了罪魁祸首…我的 React 组件呈现在错误的位置：

```jsx
<!-- 测试环境下一切正常 -->

<main>
  <div class="ContentFooter">
    Last updated: <strong>Sometime</strong>
  </div>
  <div class="NewsletterSignup">
    <form>
      <!-- Newsletter signup form stuff -->
    </form>
  </div>
</main>
```

```jsx
<!-- 在生产环境, 代码就乱飞了 -->

<main>
  <div class="ContentFooter">
    Last updated: <strong>Sometime</strong>
    <div class="NewsletterSignup">
      <form>
        <!-- Newsletter signup form stuff -->
      </form>
    </div>
  </div>
</main>
```

​ 怎么会这样？难道我发现了 React 中的一个 Bug？我检查了 React Devtools 的 "⚛️Components " 选项卡，它告诉了我一个不同的故事，在这个故事里，一切都很好，所有的部件都躺在它们应该在的地方。骗子啊!

​ 原来，我对 React 在 SSR 下的工作方式有了根本性的误解。而我想**很多**React 开发人员都有这样的误解! 而且它可能会带来一些很严重的影响。

> 作者在出了个视频教程, 教程内容就是复现 gatsby 在 ssr 生产环境产生的错误渲染, 及其原因和解决办法
>
> [视频链接](https://egghead.io/lessons/react-avoiding-state-flickers-in-gatsby-applications?pl=undefined&af=49agrw)

## 一些有问题的代码

​ 下面这个是一段会导致错误渲染的问题代码, 你能找到问题在哪吗?

```jsx
function Navigation() {
  if (typeof window === 'undefined') {
    return null;
  }
  // 假设个function存在
  // 并返回 user 对象或者 null
  const user = getUser();
  if (user) {
    return <AuthenticatedNav user={user} />;
  }
  return (
    <nav>
      <a href="/login">Login</a>
    </nav>
  );
}
```

​ 很长一段时间，我都会认为这个代码是 OK 的。直到有一天我的博客变成了毕加索的画。

​ 本教程找到幕后的原因，使我们了解服务器端渲染的工作原理。我们将知道为什么这段代码的逻辑会有问题，以及我们如何用不同的方法来实现避免出现这样的错误。

## Server-side rendering 101(101 是个什么梗?)

​ 想要理解这个问题，我们需要先了解一下 Gatsby 或 Next.js 这种 SSR 框架和普通的 client-side 通过 react 构建的应用之间的区别。

​ 当你通过 create-react-app 这种脚手架构建 react 应用的时候，所有的渲染都发生在浏览器中。不管你的应用有多大，浏览器都将收到一个初始的 HTML 文档，看起来就像这样：

```html
<!DOCTYPE html>
<html lang="en">
  <head>
    <!-- Maybe some stuff here -->
  </head>
  <body>
    <div id="root"></div>
    <script src="/static/bundle.js"></script>
    <script src="/static/0.chunk.js"></script>
    <script src="/static/main.chunk.js"></script>
  </body>
</html>
```

​ 这个页面基本上是空的，但它包括几个 JS 脚本。一旦浏览器下载并解析了这些脚本，React 就会建立一个页面应该是什么样子的切片，并注入一堆 DOM 节点使之成为这样的切片。这就是所谓的客户端渲染(client-side-render)，因为所有的渲染都发生在客户端（用户的浏览器）中。

​ 但所有这些过程都会耗时，当浏览器和 React 在施展魔法时，屏幕前用户却只能盯着空白的屏幕。这不是最好的体验。

​ 聪明的人意识到，如果我们能在服务器上进行渲染，我们就能给用户发送一个完整的 HTML 文档。这样一来，当浏览器下载、解析和执行 JS 的时候，他们就有东西可看了。这就是所谓的服务器端渲染（SSR）。

​ 服务器端渲染可以在性能上取胜，但问题是，这些工作仍然需要按需完成。当你请求 your-website.com 时，React 必须将你的 React 组件转化为 HTML，而你在等待的过程中仍然会盯着一个空白的屏幕。只是这些工作是在服务器上完成的，而不是在用户的电脑上。

​ 更机智的人发现，许多网站和应用的一些大的代码 chunk 是静态的，它们可以在编译时构建。我们可以提前在我们的开发机器上生成初始 HTML，并在用户请求时立即分发。我们的 React 应用可以像普通的 HTML 网站一样快速加载！这正是 Gatsby 所做的。

​ 这正是 Gatsby 所做的事情（以及 Next.js，在某些配置下）。当你运行 yarn 构建时，它会为你网站上的每一条路径生成一个 HTML 文档。每一个侧页、每一篇博客文章、每一个商店项目--都会为它们创建一个 HTML 文件，并准备好立即提供。

> ​ 这一切只是服务器端的渲染吗？
> ​ 不幸的是，这种进行了多次语言转换，而且这个过程可能非常难以理解。从技术上讲，Gatsby 所做的是服务器端渲染，因为它在 Node.js 上使用相同的 ReactDOMServer API 来渲染 React 应用，就像一个传统的服务器端渲染一样。不过在我看来，这两者在概念上是不同的。"服务器端渲染 "是在你的实时生产服务器上实时发生的，是对请求的响应，而 Gatsby 在编译时即进行渲染则发生得更早，是构建过程的一部分。
>
> ​ 有些人开始把它称为 SSG，它要么代表 "Static Site Generation"，要么代表 "Server-Side Generate"，这取决于你问谁。

### 客户端上的代码

​ 现在我们构建的应用都是交互式、动态的---用户已经习惯了单靠 HTML 和 CSS 无法完成的网页体验！所以我们仍然需要运行客户端的 JS。

​ 客户端 JS 包括在编译时生成的相同的 React 代码。它在用户的设备上运行，并建立一个整个网页应该是什么样子的切片。然后，它将其与文档中构建的 HTML 进行比较。这是一个被称为补水(`rehydration`)的过程。（译者：在 ssr 中，没有添加 react 脚本的 dom tree 就像干巴巴的枯枝，把 js 代码注入进去的过程就像给干海绵注水，所以才叫`rehydration`）

​ 关键的是，`rehydration`与渲染不是一回事。在典型的渲染中，当`props`或`state`发生变化时，React 会比对差异并更新 DOM。在`rehydration`中，React 假设 DOM 不会改变。它只是试图采用现有的 DOM。

## 动态变化的 Sections

让我们重回代码：

```jsx
const Navigation = () => {
  if (typeof window === 'undefined') {
    return null;
  }
  // Pretend that this function exists,
  // and returns either a user object or `null`.
  const user = getUser();
  if (user) {
    return <AuthenticatedNav user={user} />;
  }
  return (
    <nav>
      <a href="/login">Login</a>
    </nav>
  );
};
```

按逻辑，这个组件会返回三种可能的结果：

- 如果 user 登录了， 渲染`<AuthenticatedNav>`组件
- 如果 user 不登录，渲染`<UnauthenticatedNav>`组件
- 如果我们不知道 user 登录与否, 什么都不渲染。

### 薛定谔的 user

​ 对于我们的 app 而言， 在用户进入往后的前几分钟，我们并不知道他们是否已经登录， 就像薛定谔的猫。

​ 这是因为 HTML 文件是在编译时建立的。无论他们是否登录，每个用户都会得到一份相同的 HTML 副本。一旦 JS bundle 被解析和执行，我们就可以更新 UI 来反映用户的状态，但在这之前有一个很大的时间差。请记住，SSG 的目的是在我们下载、解析和`rehydration`应用时给用户一些东西看，这在 3G 冲浪的设备上可能是一个漫长的过程。

​ 许多 webapps 选择默认显示 "注销 "状态，这就导致了你之前可能遇到的闪烁情况(作者的视频，我搬不了)。

import VideoComponent from '../../../src/components/Video.tsx';

<VideoComponent src="https://www.joshwcomeau.com/_next/static/media/guardian-with-effect-5c8e3ed088ad6d3b9efa334a4dd7f62b.mp4" />
